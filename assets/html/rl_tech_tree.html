<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>RL Tech Tree DAG</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            margin: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont;
            background: #0f122a;
            color: #e5e7eb;
        }

        svg {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        .link {
            fill: none;
            stroke: #64748b;
            stroke-width: 2px;
            opacity: 0.6;
        }

        .node circle {
            r: 30;
            fill: #1e293b;
            stroke: #b1d4e2;
            stroke-width: 2px;
        }

        .node text {
            fill: #e5e7eb;
            font-size: 20px;
            text-anchor: middle;
            pointer-events: none;
            transform: translateY(60px);
        }

        .tooltip {
            position: absolute;
            background: #020617;
            border: 1px solid #334155;
            padding: 11px;
            border-radius: 6px;
            font-size: 15px;
            pointer-events: none;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .x-axis path,
        .x-axis line {
            stroke: #475569;
        }

        .x-axis text {
            fill: #e5e7eb;
            font-size: 16px;
        }

        .axis-label {
            fill: #e5e7eb;
            font-size: 20px;
            font-weight: 600;
        }
    </style>
</head>

<body>
    <svg></svg>

    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;
        const margin = { top: 50, right: 80, bottom: 80, left: 80 };

        const svg = d3.select("svg");
        const g = svg.append("g");

        /* -----------------------------
           Load JSON
        ----------------------------- */
        d3.json("tech_tree.json").then(data => {

            // Map nodes by id
            const nodeMap = new Map();
            data.nodes.forEach(n => nodeMap.set(n.id, n));

            // Build children array based on prerequisites
            data.nodes.forEach(n => { n.children = []; });
            data.nodes.forEach(n => {
                if (n.prerequisites) n.prerequisites.forEach(p => {
                    const parent = nodeMap.get(p);
                    if (parent) parent.children.push(n);
                });
            });

            // Find roots (nodes without prerequisites)
            const roots = data.nodes.filter(n => !n.prerequisites || n.prerequisites.length === 0);

            // Horizontal scale (year)
            const years = data.nodes.map(d => d.year);
            const minYear = d3.min(years) - 1, maxYear = d3.max(years) + 1;
            const rowHeight = 300;
            // Define key "break points" in years and corresponding x positions
            const yearBreaks = [1957, 1985, 1995, 2002, 2013, 2020, 2024];
            const xBreaks = [margin.left, 200, 700, 1200, 1300, 2200, width - margin.right];
            const xScale = d3.scaleLinear()
                .domain(yearBreaks)
                .range(xBreaks)
                .clamp(true);

            // DFS row assignment
            const visited = new Set(); // global set to track visited nodes
            const rowCounter = {}; // tracks row for each depth
            const parentrows = {};
            parentrows[0] = 0;
            function dfs(node, depth = 0) {
                if (visited.has(node.id)) return; // skip if already processed
                visited.add(node.id);
                if (!rowCounter[node.year]) rowCounter[node.year] = 0;
                if (depth > 0 && !parentrows[depth]) {
                    parentrows[depth] = parentrows[depth - 1];
                }
                if (rowCounter[node.year] > parentrows[depth]) {
                    node.row = rowCounter[node.year];
                }
                else {
                    node.row = parentrows[depth];
                }

                parentrows[depth] = node.row;
                node.y = node.row * rowHeight + margin.top;  // vertical
                node.x = xScale(node.year);                  // horizontal
                rowCounter[node.year]++;
                if (node.children) node.children.forEach(child => dfs(child, depth + 1));
                parentrows[depth] = 0;
            }

            // Run DFS from all roots
            roots.sort((a, b) => a.year - b.year);
            roots.forEach(root => dfs(root));

            // Build links
            const links = [];
            data.nodes.forEach(n => {
                if (n.prerequisites) n.prerequisites.forEach(p => {
                    const parent = nodeMap.get(p);
                    if (parent) links.push({ source: parent, target: n });
                });
            });

            // Extract all unique branches for vertical lanes
            const branches = Array.from(new Set(data.nodes.map(d => d.branch)));
            const branchY = d3.scalePoint()
                .domain(branches)
                .range([margin.top, height - margin.bottom])
                .padding(0.5);

            // Extract year range for horizontal axis



            // Build links for all prerequisites


            /* -----------------------------
               Draw links
            ----------------------------- */
            g.selectAll(".link")
                .data(links)
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("d", d => {
                    return `M${d.source.x},${d.source.y} 
              C${d.source.x + 50},${d.source.y} 
               ${d.target.x - 50},${d.target.y} 
               ${d.target.x},${d.target.y}`;
                });

            /* -----------------------------
               Draw nodes
            ----------------------------- */
            const node = g.selectAll(".node")
                .data(data.nodes)
                .enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x}, ${d.y})`);

            node.append("circle");
            node.append("text").text(d => d.id);

            /* -----------------------------
               Tooltip
            ----------------------------- */
            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            node.on("mouseover", (event, d) => {
                tooltip.style("opacity", 1)
                    .html(`
        <strong>${d.name}</strong> (${d.year})<br><br>
        <em>Improvement:</em><br>${d.improvement}<br><br>
        <em>Solves:</em><br>${d.solves}<br><br>
        ${d.equations ? '<em>Equations:</em><br>' + d.equations.join("<br>") + '<br><br>' : ''}
        ${d.references ? '<em>References:</em><br>' + d.references.join("<br>") : ''}
      `);
            })
                .on("mousemove", (event) => {
                    tooltip.style("left", event.pageX + 15 + "px")
                        .style("top", event.pageY + 15 + "px");
                })
                .on("mouseout", () => tooltip.style("opacity", 0));

            /* -----------------------------
               Draw horizontal year axis
            ----------------------------- */
            const xAxis = d3.axisBottom(xScale)
                .tickValues([1957, 1983, 1990, 1996, 1998, 2013, 2015, 2017, 2018, 2020, 2024])
                .tickFormat(d3.format("d"));

            const axisGroup = svg.append("g")
                .attr("class", "x-axis")
                .attr("transform", `translate(0, ${height - margin.bottom})`)
                .call(xAxis);

            axisGroup.append("text")
                .attr("class", "axis-label")
                .attr("x", width / 2)
                .attr("y", 60)
                .attr("text-anchor", "middle")
                .text("Reinforcement Learning Timeline (Year)");

            /* -----------------------------
               Zoom / Pan
            ----------------------------- */
            svg.call(
                d3.zoom()
                    .scaleExtent([0.4, 2])
                    .on("zoom", (event) => {
                        g.attr("transform", event.transform);
                        axisGroup.attr(
                            "transform",
                            `translate(${event.transform.x}, ${height - margin.bottom}) scale(${event.transform.k},1)`
                        );
                    })
            );

        });
    </script>
</body>

</html>